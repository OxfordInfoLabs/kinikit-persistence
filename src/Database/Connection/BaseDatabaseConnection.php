<?php


namespace Kinikit\Persistence\Database\Connection;


use Kinikit\Core\Configuration\Configuration;
use Kinikit\Core\Util\ArrayUtils;

/**
 * Base database connection which implements common defaults for the database connection.
 *
 * It is constructed with a config key which matches a configuration (Can be left blank for default)
 * defined in the config file.
 *
 * Class BaseDatabaseConnection
 * @package Kinikit\Persistence\Database\Connection
 */
abstract class BaseDatabaseConnection implements DatabaseConnection {

    /**
     * Transaction depth variable for nested transaction management.
     *
     * @var integer
     */
    protected $transactionDepth;

    /**
     * @var string
     */
    private $logFile;


    /**
     * @var string
     */
    private $lastErrorMessage;

    /**
     * Constructor - calls connect automatically to prevent need to call connect explicitly
     *
     * BaseDatabaseConnection constructor.
     *
     * @param string $configKey
     *
     * @throws DatabaseConnectionException
     */
    public function __construct($configKey = null) {
        $connected = $this->connect();
        if (!$connected)
            throw new DatabaseConnectionException();

        // Calculate the prefix to look for with configuration.
        $prefix = $configKey ? "db.$configKey." : "db.";

        $allConfigParams = Configuration::instance()->getAllParameters();
        $dbConfigParams = [];
        foreach ($allConfigParams as $key => $param) {
            if (strncmp($key, $prefix, strlen($prefix)) === 0) {
                $newKey = substr($key, strlen($prefix));
                if (!strpos($newKey, "."))
                    $dbConfigParams[$newKey] = $param;
            }
        }


        if (isset($dbConfigParams["logFile"]))
            $this->logFile = $dbConfigParams["logFile"];

        // Connect using the filtered params.
        $this->connect($dbConfigParams);

    }


    /**
     * Log a string to the database log.
     *
     * @param string $string
     */
    public function log($string) {
        if ($this->logFile) {
            file_put_contents($this->logFile, $string, FILE_APPEND);
        }
    }

    /**
     * Executes a callable with time based logging.
     *
     * @param callable $callable
     * @param string $logString
     */
    public function executeCallableWithLogging($callable, $logString) {

        // if a log file, execute with timings and logging, otherwise run callable intact.
        if ($this->logFile) {
            $startTime = microtime(true);
            $result = $callable();
            $endTime = microtime(true);
            $this->log($logString . "\nCompleted in " . round($endTime - $startTime, 4) . " seconds");
            return $result;
        } else {
            return $callable();
        }

    }


    /**
     * Standard begin transaction logic for most systems.
     *
     * @throws SQLException
     */
    public function beginTransaction() {

        // Increase the transaction depth
        $this->transactionDepth++;

        // If not in transaction, start a transaction
        if ($this->transactionDepth == 1) {
            $this->query("BEGIN");
        } else {
            $this->query("SAVEPOINT SP" . $this->transactionDepth);
        }

    }

    /**
     * Standard implementation of commit for a transaction.
     *
     * @throws SQLException
     */
    public function commit() {

        $this->query("COMMIT");

        // Reset the transaction depth
        $this->transactionDepth = 0;

    }

    /**
     * Standard implementation of rollback for a transaction
     *
     * @param bool $wholeTransaction
     *
     * @throws SQLException
     */
    public function rollback($wholeTransaction = true) {


        if ($this->transactionDepth <= 1 || $wholeTransaction) {
            $this->query("ROLLBACK");
        } else {
            $this->query("ROLLBACK TO SAVEPOINT SP" . $this->transactionDepth);
        }

        // Decrement the transaction depth
        $this->transactionDepth = $wholeTransaction ? 0 : max(0, $this->transactionDepth - 1);

    }


    /**
     * Set the last error message
     *
     * @param string $lastErrorMessage
     */
    protected function setLastErrorMessage($lastErrorMessage) {
        $this->lastErrorMessage = $lastErrorMessage;
    }

    /**
     * Get the last error message generated by this connection
     *
     * @return string
     */
    public function getLastErrorMessage() {
        return $this->lastErrorMessage;
    }


}
